import numpy as np
from scipy.interpolate import Akima1DInterpolator, RectBivariateSpline, RegularGridInterpolator, RBFInterpolator, LinearNDInterpolator

from flight_simulator import Q_, ureg, REPO_ROOT_FOLDER
from flight_simulator.core.dynamics.aircraft_states import AircraftStates
from flight_simulator.core.dynamics.vector import Vector
from flight_simulator.core.loads.forces_moments import ForcesMoments
from flight_simulator.core.loads.loads import Loads
from flight_simulator.core.vehicle.conditions.aircraft_conditions import CruiseCondition
from flight_simulator.core.vehicle.controls.vehicle_control_system import (
    VehicleControlSystem, ControlSurface, PropulsiveControl)
from flight_simulator.core.dynamics.axis import Axis, ValidOrigins
from flight_simulator.core.loads.mass_properties import MassProperties, MassMI
from flight_simulator.core.vehicle.components.component import Component
from flight_simulator.core.vehicle.components.aircraft import Aircraft
from typing import Union
from typing import List
import csdl_alpha as csdl
from modopt import CSDLAlphaProblem, SLSQP, IPOPT, SNOPT, PySLSQP, COBYLA
import time
import scipy.io as sio
import NRLMSIS2
import pandas as pd

ft2m = 0.3048  # feet to meters conversion factor

# Every CSDl code starts with a recorder
recorder = csdl.Recorder(inline=True)
recorder.start()

# Load Data files
folder_path = REPO_ROOT_FOLDER / 'examples'/ 'basic_examples' / 'b777' 
thrust_data = sio.loadmat(folder_path / 'TminTmax.mat')
dragpolar_data = sio.loadmat(folder_path / 'DragPolar.mat')
aerocoeffs_data = sio.loadmat(folder_path / 'AeroDerivatives.mat')
eng_inp_data = sio.loadmat(folder_path / 'eng_inputs.mat')
eng_out_data = sio.loadmat(folder_path / 'eng_outputs.mat')
eng_deriv_data = sio.loadmat(folder_path / 'eng_derivs.mat')


# region Axes

# I am picking the inertial axis location as the OpenVSP (0,0,0)
inertial_axis = Axis(
    name='Inertial Axis',
    origin=ValidOrigins.Inertial.value
)

openvsp_axis = Axis(
        name='OpenVSP Axis',
        x=Q_(0, 'm'),
        y=Q_(0, 'm'),
        z=Q_(0, 'm'),
        origin=ValidOrigins.OpenVSP.value
    )

fd_axis = Axis(
    name='Flight Dynamics Body Fixed Axis',
    x=Q_(0, 'ft'),
    y=Q_(0, 'ft'),
    z=Q_(0, 'ft'),  # z is positive down in FD axis
    phi=Q_(0, 'deg'),
    theta=Q_(0, 'deg'),
    psi=Q_(0, 'deg'),
    sequence=np.array([3, 2, 1]),
    reference=inertial_axis,
    origin=ValidOrigins.Inertial.value
)



# region Aircraft Component

# Create a Mass Properties object with given values
b777_mi = MassMI(axis=fd_axis,
                 Ixx=Q_(18663676.936422713, 'kg*(m*m)'),
                 Iyy=Q_(47812509.66393921, 'kg*(m*m)'),
                 Izz=Q_(63555637.7196545, 'kg*(m*m)'),
                 Ixy=Q_(0, 'kg*(m*m)'),
                 Ixz=Q_(0, 'kg*(m*m)'),
                 Iyz=Q_(0, 'kg*(m*m)'))
b777_mass_properties = MassProperties(mass=Q_(294814, 'kg'),
                                      inertia=b777_mi,
                                      cg=Vector(vector=Q_(np.array([0, 0, 0]), 'm'), axis=fd_axis))

aircraft_component = Aircraft()
aircraft_component.mass_properties = b777_mass_properties
# endregion

# region Fuselage Component
fuselage_component = Component(name='Fuselage')
aircraft_component.add_subcomponent(fuselage_component)

# region Engine Component
left_engine_axis = Axis(
    name='Engine Axis',
    x=Q_(-66.693, 'ft'),
    y=Q_(30.6667, 'ft'),
    z=Q_(6.7656, 'ft'),  # z is positive down in FD axis
    phi=Q_(0, 'deg'),
    theta=Q_(0, 'deg'),
    psi=Q_(0, 'deg'),
    sequence=np.array([3, 2, 1]),
    reference=inertial_axis,
    origin=ValidOrigins.Inertial.value
)
left_engine_mass_properties = MassProperties(mass=Q_(0, 'kg'),
                                        inertia=MassMI(axis=left_engine_axis,
                                        Ixx=Q_(0, 'kg*(m*m)'),
                                        Iyy=Q_(0, 'kg*(m*m)'),
                                        Izz=Q_(0, 'kg*(m*m)'),
                                        Ixy=Q_(0, 'kg*(m*m)'),
                                        Ixz=Q_(0, 'kg*(m*m)'),
                                        Iyz=Q_(0, 'kg*(m*m)')),
                                        cg=Vector(vector=Q_(np.array([0, 0, 0]), 'm'),
                                                    axis=left_engine_axis))


left_engine_component = Component(name='Left Engine')
left_engine_component.mass_properties = left_engine_mass_properties
fuselage_component.add_subcomponent(left_engine_component)

right_engine_axis = Axis(
    name='Right Engine Axis',
    x=Q_(-66.6927, 'ft'),
    y=Q_(-30.6667, 'ft'),
    z=Q_(6.7656, 'ft'),  # z is positive down in FD axis
    phi=Q_(0, 'deg'),
    theta=Q_(0, 'deg'),
    psi=Q_(0, 'deg'),
    sequence=np.array([3, 2, 1]),
    reference=inertial_axis,
    origin=ValidOrigins.Inertial.value
)
# Create a Mass Properties object for the right engine
# Note: Assuming the right engine has the same mass properties as the left engine for simplicity
right_engine_mass_properties = MassProperties(mass=Q_(0, 'kg'),
                                             inertia=MassMI(axis=right_engine_axis,
                                            Ixx=Q_(0, 'kg*(m*m)'),
                                            Iyy=Q_(0, 'kg*(m*m)'),
                                            Izz=Q_(0, 'kg*(m*m)'),
                                            Ixy=Q_(0, 'kg*(m*m)'),
                                            Ixz=Q_(0, 'kg*(m*m)'),
                                            Iyz=Q_(0, 'kg*(m*m)')),
                                            cg=Vector(vector=Q_(np.array([0, 0, 0]), 'm'),
                                                axis=right_engine_axis))

right_engine_component = Component(name='Right Engine')
fuselage_component.add_subcomponent(right_engine_component)
right_engine_component.mass_properties = right_engine_mass_properties
# endregion

# region Wing Component
wing_component = Component(name='Wing')
aircraft_component.add_subcomponent(wing_component)
wing_axis = Axis(
    name='Wing Axis',
    x=Q_(0, 'ft'),
    y=Q_(0, 'ft'),
    z=Q_(0, 'ft'),  # z is positive down in FD axis
    phi=Q_(0, 'deg'),
    theta=Q_(0, 'deg'),
    psi=Q_(0, 'deg'),
    sequence=np.array([3, 2, 1]),
    reference=inertial_axis,
    origin=ValidOrigins.Inertial.value
)
b777_wing_mass_properties = MassProperties(mass=Q_(0, 'kg'),
                                           inertia=MassMI(axis=fd_axis,
                                                          Ixx=Q_(0, 'kg*(m*m)'),
                                                          Iyy=Q_(0, 'kg*(m*m)'),
                                                          Izz=Q_(0, 'kg*(m*m)'),
                                                          Ixy=Q_(0, 'kg*(m*m)'),
                                                          Ixz=Q_(0, 'kg*(m*m)'),
                                                          Iyz=Q_(0, 'kg*(m*m)')),
                                           cg=Vector(vector=Q_(np.array([0, 0, 0]), 'm'),
                                                     axis=fd_axis))
wing_component.mass_properties = b777_wing_mass_properties

# endregion

# region Control Surface Components
rudder_component = Component(name='Rudder')
rudder_component.parameters.actuate_angle = csdl.Variable(name="Rudder Actuate Angle", shape=(1,), value=np.deg2rad(0))
# aircraft_component.add_subcomponent(rudder_component)

elevator_component = Component(name='Elevator')
elevator_component.parameters.actuate_angle = csdl.Variable(name="Elevator Actuate Angle", shape=(1,), value=np.deg2rad(0))
# aircraft_component.add_subcomponent(elevator_component)

left_aileron_component = Component(name='Left Aileron')
left_aileron_component.parameters.actuate_angle = csdl.Variable(name="Left Aileron Actuate Angle", shape=(1,), value=np.deg2rad(0))
# wing_component.add_subcomponent(left_aileron_component)
right_aileron_component = Component(name='Right Aileron')
right_aileron_component.parameters.actuate_angle = csdl.Variable(name="Right Aileron Actuate Angle", shape=(1,), value=np.deg2rad(0))
# wing_component.add_subcomponent(right_aileron_component)
# endregion

# region Aircraft Controls
class B777Control(VehicleControlSystem):

    def __init__(self, elevator_component, aileron_right_component, aileron_left_component, rudder_component, symmetrical: bool = True):

        self.elevator = ControlSurface('elevator', lb=-30, ub=30, component=elevator_component)
        self.aileron_left = ControlSurface('aileron_left', lb=-20, ub=20, component=aileron_right_component)
        self.aileron_right = ControlSurface('aileron_right', lb=-20, ub=20, component=aileron_left_component)
        self.engine_left = PropulsiveControl(name='engine_left', throttle=0.45)
        self.engine_right = PropulsiveControl(name='engine_right', throttle=0.52)
        self.rudder = ControlSurface('rudder', lb=-16, ub=16, component=rudder_component)
        
        self.u = csdl.concatenate((self.aileron_left.deflection,
                                    self.aileron_right.deflection,
                                    self.elevator.deflection,
                                    self.rudder.deflection,
                                    self.engine_left.throttle,
                                    self.engine_right.throttle), axis=0)

        super().__init__(pitch_control=[self.elevator],
                            roll_control=[self.aileron_left, self.aileron_right],
                            yaw_control=[self.rudder],
                            throttle_control=[self.engine_left,self.engine_right])

    @property
    def control_order(self) -> List[str]:
        return ['roll', 'pitch', 'yaw', 'throttle']

    @property
    def lower_bounds(self):
        lb_elevator = self.elevator.lower_bound
        lb_rudder = self.rudder.lower_bound
        lb_thr_left = self.engine_left.lower_bound
        lb_thr_right = self.engine_right.lower_bound
        lb_aileron_left = self.aileron_left.lower_bound
        lb_aileron_right = self.aileron_right.lower_bound
        return np.array([lb_aileron_left, lb_aileron_right, lb_elevator, lb_rudder, lb_thr_left, lb_thr_right])

    @property
    def upper_bounds(self):
        ub_elevator = self.elevator.upper_bound
        ub_rudder = self.rudder.upper_bound
        ub_thr_left = self.engine_left.upper_bound
        ub_thr_right = self.engine_right.upper_bound
        ub_aileron_left = self.aileron_left.upper_bound
        ub_aileron_right = self.aileron_right.upper_bound
        return np.array([ub_aileron_left, ub_aileron_right, ub_elevator, ub_rudder, ub_thr_left, ub_thr_right])


B777_controls = B777Control(elevator_component=elevator_component, aileron_right_component=right_aileron_component,
                            aileron_left_component=left_aileron_component, rudder_component=rudder_component)

# endregion

# Wing / Aero Data
class B777Aerodynamics(Loads):
    def __init__(self, CDML_interp, CDHM_interp, aero_coefficients, S, b, c, FCDSUB: float=1., FCDI: float=1., FCDO: float=1.):
        self.S = S
        self.b = b
        self.c = c
        # Drag polar
        self.CDML_interp = CDML_interp
        self.CDHM_interp = CDHM_interp
        self.FCDSUB = FCDSUB
        self.FCDI = FCDI
        self.FCDO = FCDO
        # Aerodynamic coefficients
        self.aero_coeffs = aero_coefficients

    def get_FM_localAxis(self, states, controls, axis):

        density = states.atmospheric_states.density
        velocity = states.VTAS
        axis = states.axis
        mach=states.Mach
        AOA = states.alpha
        beta = states.beta

        p = states.states.p
        q = states.states.q
        r = states.states.r
        theta = states.states.theta
        h = -states.states.z

        da = controls.roll_control[0].deflection
        dr = controls.yaw_control[0].deflection
        de = controls.pitch_control[0].deflection

        phat = p * self.b / (2 * velocity)
        qhat = q * self.c / (2 * velocity)
        rhat = r * self.b / (2 * velocity)

        kPG = csdl.sqrt(1 - mach**2)  # Prandtl-Glauert(beta)

        cdml_curve = type(self.CDML_interp)()
        cdhm_curve = type(self.CDHM_interp)()
        
        CL = (self.aero_coeffs['CL0'][0][0] +
              self.aero_coeffs['CLa'][0][0] * AOA +
              self.aero_coeffs['CLb'][0][0] * beta +
              self.aero_coeffs['CLp'][0][0] * phat +
              self.aero_coeffs['CLq'][0][0] * qhat +
              self.aero_coeffs['CLr'][0][0] * rhat +
              self.aero_coeffs['CLda'][0][0] * da +
              self.aero_coeffs['CLde'][0][0] * de +
              self.aero_coeffs['CLdr'][0][0] * dr)/kPG

        CD = self.FCDSUB * (self.FCDI * cdml_curve.evaluate(mach=mach, CL=CL).cdml + self.FCDO * cdhm_curve.evaluate(h, mach).cdhm) + \
             self.aero_coeffs['CDda'][0][0] * da + \
             self.aero_coeffs['CDde'][0][0] * de + \
             self.aero_coeffs['CDdr'][0][0] * dr
        

        CY = (self.aero_coeffs['CYa'][0][0] * AOA +
              self.aero_coeffs['CYb'][0][0] * beta +
              self.aero_coeffs['CYp'][0][0] * phat +
              self.aero_coeffs['CYq'][0][0] * qhat +
              self.aero_coeffs['CYr'][0][0] * rhat +
              self.aero_coeffs['CYda'][0][0] * da +
              self.aero_coeffs['CYde'][0][0] * de +
              self.aero_coeffs['CYdr'][0][0] * dr)/kPG

        Cm = (self.aero_coeffs['Cm0'][0][0] +
              self.aero_coeffs['Cma'][0][0] * AOA +
              self.aero_coeffs['Cmb'][0][0] * beta +
              self.aero_coeffs['Cmp'][0][0] * phat +
              self.aero_coeffs['Cmq'][0][0] * qhat +
              self.aero_coeffs['Cmr'][0][0] * rhat +
              self.aero_coeffs['Cmda'][0][0] * da +
              self.aero_coeffs['Cmde'][0][0] * de +
              self.aero_coeffs['Cmdr'][0][0] * dr)/kPG

        Cn = (self.aero_coeffs['Cna'][0][0] * AOA +
              self.aero_coeffs['Cnb'][0][0] * beta +
              self.aero_coeffs['Cnp'][0][0] * phat +
              self.aero_coeffs['Cnq'][0][0] * qhat +
              self.aero_coeffs['Cnr'][0][0] * rhat +
              self.aero_coeffs['Cnda'][0][0] * da +
              self.aero_coeffs['Cnde'][0][0] * de +
              self.aero_coeffs['Cndr'][0][0] * dr)/kPG

        Cl = (self.aero_coeffs['Cla'][0][0] * AOA +
              self.aero_coeffs['Clb'][0][0] * beta +
              self.aero_coeffs['Clp'][0][0] * phat +
              self.aero_coeffs['Clq'][0][0] * qhat +
              self.aero_coeffs['Clr'][0][0] * rhat +
              self.aero_coeffs['Clda'][0][0] * da +
              self.aero_coeffs['Clde'][0][0] * de +
              self.aero_coeffs['Cldr'][0][0] * dr)/kPG
        
        qBar = 1/2 * density * velocity**2
        L = qBar * self.S * CL
        D = qBar * self.S * CD
        Y = qBar * self.S * CY
        l = qBar * self.S * self.b * Cl
        m = qBar * self.S * self.c * Cm
        n = qBar * self.S * self.b * Cn

        force_vector = Vector(vector=csdl.concatenate((-D, 0, -L),
                                                      axis=0), axis=axis)

        moment_vector = Vector(vector=csdl.Variable(shape=(3,), value=0.), axis=axis)
        loads = ForcesMoments(force=force_vector, moment=moment_vector)
        return {'loads': loads, 'CL': CL, 'CD': CD, 'CY': CY, 'Cm': Cm, 'Cn': Cn, 'Cl': Cl}

#TODO: Make sure these are correct, implement Quantity and conversion by default inside the class
b = 199.14 * ft2m # Wing span in m
S = 4927.3 * ft2m**2  # Wing area in m^2
c= 4927.3/199.14*ft2m

class CDML(csdl.CustomExplicitOperation):

    def __init__(self):
        super().__init__()
        # Taken from JPROP
        dragpolar_CL_data = dragpolar_data['CL']
        dragpolar_M_data = dragpolar_data['M']
        dragpolar_CDML_data = dragpolar_data['CDML']
        self.cdml = RectBivariateSpline(dragpolar_M_data,dragpolar_CL_data,dragpolar_CDML_data, kx=3, ky=3)

    # def evaluate(self, inputs: csdl.VariableGroup):
    def evaluate(self, mach: csdl.Variable,CL: csdl.Variable):
        # assign method inputs to input dictionary
        self.declare_input('CL', CL)
        self.declare_input('mach', mach)

        # declare output variables
        cdml = self.create_output('cdml', shape=(1, ))

        # construct output of the model
        outputs = csdl.VariableGroup()
        outputs.cdml = cdml

        return outputs

    def compute(self, input_vals, output_vals):
        CL = input_vals['CL']
        mach = input_vals['mach']
        output_vals['cdml'] = self.cdml.ev(mach, CL)


    def compute_derivatives(self, input_vals, outputs_vals, derivatives):
        CL = input_vals['CL']
        mach = input_vals['mach']
        derivatives['cdml', 'mach'] = np.diag(self.cdml.ev(mach, CL, dx=1))
        derivatives['cdml', 'CL'] = np.diag(self.cdml.ev(mach, CL, dy=1))

class CDHM(csdl.CustomExplicitOperation):

    def __init__(self):
        super().__init__()

        h_m_data = dragpolar_data['h_m']
        M_data = dragpolar_data['M']
        cdhm_data = dragpolar_data['CDHM']
        self.cdhm = RectBivariateSpline(h_m_data, M_data, cdhm_data, kx=3, ky=3)

    def evaluate(self, M: csdl.Variable, h_m: csdl.Variable):
        self.declare_input('M', M)
        self.declare_input('h_m', h_m)
        cdhm = self.create_output('cdhm', shape=(1,))
        outputs = csdl.VariableGroup()
        outputs.cdhm = cdhm
        return outputs

    def compute(self, input_vals, output_vals):
        M = input_vals['M']
        h_m = input_vals['h_m']
        output_vals['cdhm'] = self.cdhm.ev(h_m, M)

    def compute_derivatives(self, input_vals, outputs_vals, derivatives):
        M = input_vals['M']
        h_m = input_vals['h_m']
        derivatives['cdhm', 'h_m'] = np.diag(self.cdhm.ev(h_m, M, dx=1))
        derivatives['cdhm', 'M'] = np.diag(self.cdhm.ev(h_m, M, dy=1))

CDML_interp = CDML()
CDHM_interp = CDHM()

B777_wing_aero = B777Aerodynamics(CDML_interp=CDML_interp,
                                    CDHM_interp=CDHM_interp,
                                    aero_coefficients=aerocoeffs_data,
                                    S=S, b=b, c=c)
                                    
wing_component.load_solvers.append(B777_wing_aero)
# region Propulsion Model

class B777SMTPropulsion(Loads):
    def __init__(self, engine_curve, is_left_engine: bool = True):
        self.engine_curve = engine_curve
        self.is_left_engine = is_left_engine

    def get_FM_localAxis(self, states, controls, axis):
        if self.is_left_engine:
            throttle = controls.engine_left.throttle
        else:
            throttle = controls.engine_right.throttle
        
        axis = states.axis
        h = -states.states.z/1000
        M = states.Mach

        thrust_eng_curve = type(self.engine_curve)()
        sfc_eng_curve = type(self.engine_curve)()
        T = thrust_eng_curve.evaluate(mach=M, altitude=h, throttle=throttle).thrust
        sfc = sfc_eng_curve.evaluate(mach=M, altitude=h, throttle=throttle).sfc

        force_vector = Vector(vector=csdl.concatenate((T, 0, 0),
                                                      axis=0), axis=axis)

        moment_vector = Vector(vector=csdl.Variable(shape=(3,), value=0.), axis=axis)
        loads = ForcesMoments(force=force_vector, moment=moment_vector)
        return loads

class B777SMTEngineCurve(csdl.CustomExplicitOperation):
    def __init__(self):
        super().__init__()
        # taken from Surrogate Modelling Toolbox (SMT) B777 Example Engine Data
        propcurve_mach_data = eng_inp_data['mach']
        propcurve_alt_data = eng_inp_data['alt']
        propcurve_throttle_data = eng_inp_data['thrott']
        points = np.column_stack((propcurve_mach_data, propcurve_alt_data, propcurve_throttle_data))
        thrust_data = eng_out_data['thrust']
        sfc_data = eng_out_data['sfc']
        dTdM = eng_deriv_data['dTdM']
        dTdAlt = eng_deriv_data['dTda']
        dTdth = eng_deriv_data['dTdth']
        dSFCdM = eng_deriv_data['dSdM']
        dSFCdAlt = eng_deriv_data['dSda']
        dSFCdth = eng_deriv_data['dSdth']
        self.thrust = RBFInterpolator(points, thrust_data, kernel='multiquadric', epsilon=2)
        self.sfc = RBFInterpolator(points, sfc_data, kernel='multiquadric', epsilon=2)
        self.dTdM = RBFInterpolator(points, dTdM, kernel='multiquadric', epsilon=2)
        self.dTdAlt = RBFInterpolator(points, dTdAlt, kernel='multiquadric', epsilon=2)
        self.dTdth = RBFInterpolator(points, dTdth, kernel='multiquadric', epsilon=2)
        self.dSFCdM = RBFInterpolator(points, dSFCdM, kernel='multiquadric', epsilon=2)
        self.dSFCdAlt = RBFInterpolator(points, dSFCdAlt, kernel='multiquadric', epsilon=2)
        self.dSFCdth = RBFInterpolator(points, dSFCdth, kernel='multiquadric', epsilon=2)


    def evaluate(self, mach: csdl.Variable, altitude: csdl.Variable, throttle: csdl.Variable):
        self.declare_input('mach', mach)
        self.declare_input('altitude', altitude)
        self.declare_input('throttle', throttle)

        thrust = self.create_output('thrust', shape=(1,))
        sfc = self.create_output('sfc', shape=(1,))

        outputs = csdl.VariableGroup()
        outputs.thrust = thrust
        outputs.sfc = sfc

        return outputs
    
    def compute(self, input_vals, output_vals):
        mach = input_vals['mach']
        altitude = input_vals['altitude']
        throttle = input_vals['throttle']
        output_vals['thrust'] = self.thrust(np.transpose([mach, altitude, throttle]))
        output_vals['sfc'] = self.sfc(np.transpose([mach, altitude, throttle]))

    def compute_derivatives(self, input_vals, outputs_vals, derivatives):
        mach = input_vals['mach']
        altitude = input_vals['altitude']
        throttle = input_vals['throttle']
        derivatives['thrust', 'mach'] = np.diag(self.dTdM(np.transpose([mach, altitude, throttle])))
        derivatives['thrust', 'altitude'] = np.diag(self.dTdAlt(np.transpose([mach, altitude, throttle])))
        derivatives['thrust', 'throttle'] = np.diag(self.dTdth(np.transpose([mach, altitude, throttle])))
        derivatives['sfc', 'mach'] = np.diag(self.dSFCdM(np.transpose([mach, altitude, throttle])))
        derivatives['sfc', 'altitude'] = np.diag(self.dSFCdAlt(np.transpose([mach, altitude, throttle])))
        derivatives['sfc', 'throttle'] = np.diag(self.dSFCdth(np.transpose([mach, altitude, throttle])))

        
B777_left_engine = B777SMTPropulsion(engine_curve = B777SMTEngineCurve(), is_left_engine=True)
B777_right_engine = B777SMTPropulsion(engine_curve = B777SMTEngineCurve(), is_left_engine=False)


left_engine_component.load_solvers.append(B777_left_engine)
right_engine_component.load_solvers.append(B777_right_engine)

# region Create Conditions

# region cruise_cond Condition
alt=3048/ft2m
Trequired = []
mach=0.55
cruise_cond = CruiseCondition(fd_axis=fd_axis, controls=B777_controls,
                            altitude=Q_(alt, 'ft'), mach_number=Q_(mach, 'dimensionless'),
                            range=Q_(10000, 'm'), pitch_angle=Q_(0, 'deg'))
# endregion
pass
# endregion
tf, tm = aircraft_component.compute_total_loads(fd_state=cruise_cond.ac_states,
                                                controls=cruise_cond.controls)

B777_controls.pitch_control[0].deflection.set_as_design_variable(lower=np.deg2rad(-20), upper=np.deg2rad(20))
B777_controls.engine_right.throttle.set_as_design_variable(lower=0.1,
                                                        upper=1)
B777_controls.engine_left.throttle.set_as_design_variable(lower=0.1,
                                                        upper=1)
# cruise_cond.parameters.mach_number.set_as_design_variable(lower=0.1, upper=0.9)
cruise_cond.parameters.pitch_angle.set_as_design_variable(lower=-np.deg2rad(15), upper=np.deg2rad(15))

# cruise_cond.parameters.altitude.set_as_design_variable(lower=0, upper=50000)
aero_results = B777_wing_aero.get_FM_localAxis(cruise_cond.ac_states, cruise_cond.controls, wing_axis)
Drag = aero_results['loads'].F.vector[0]
Lift = aero_results['loads'].F.vector[2]
Moment = aero_results['loads'].M.vector[1]

throttle_diff = B777_controls.engine_right.throttle - B777_controls.engine_left.throttle
throttle_diff.set_as_constraint(lower=-1e-6, upper=1e-6)
throttle_diff.name = 'Throttle (R-L) Difference'

# Lift_scaling = 1/(aircraft_component.mass_properties.mass * 9.81)
# Drag_scaling = 1/csdl.absolute(Drag)
# Moment_scaling = 1/csdl.absolute(Moment)

Lift_scaling = 1
Drag_scaling = 1
Moment_scaling = 1
pass
res1 = tf[0] * Drag_scaling 
res1.name = 'Fx Force'
res1.set_as_constraint(lower=-1e-6,upper=1e-6) 

res2 = tf[2] * Lift_scaling
res2.name = 'Fz Force'
res2.set_as_constraint(lower=-1e-6,upper=1e-6)

res4 = tm[1] * Moment_scaling
res4.name = 'My Moment'
res4.set_as_constraint(lower=-1e-1,upper=1e-1)

FM = csdl.concatenate((Drag_scaling * tf[0], Lift_scaling * tf[2], Moment_scaling * tm[1]), axis=0)
FM_res = csdl.absolute(csdl.norm(FM, ord=2))
FM_res.name = 'FM Minimization Objective'
# FM_res.set_as_constraint(lower=-1e-6,upper=1e-6) # Scale the objective for better optimization performance
FM_res.set_as_objective()


J = cruise_cond.evaluate_trim_res(component=aircraft_component)
J.name = 'J: Trim Scalar'
# J.set_as_objective()


pass

sim = csdl.experimental.JaxSimulator(
        recorder=recorder,
        gpu=False,
        additional_inputs=[],
        additional_outputs=[],
        derivatives_kwargs= {
            "concatenate_ofs" : True
        })


sim.check_optimization_derivatives()

t1 = time.time()
prob = CSDLAlphaProblem(problem_name='vertical_trim_b777', simulator=sim)
optimizer = IPOPT(problem=prob)
optimizer.solve()
optimizer.print_results()
t2 = time.time()
print('Time to solve', t2-t1)
recorder.execute()
dv_save_dict = {}
constraints_save_dict = {}
obj_save_dict = {}

dv_dict = recorder.design_variables
constraint_dict = recorder.constraints
obj_dict = recorder.objectives

for dv in dv_dict.keys():
    dv_save_dict[dv.name] = dv.value
    print("Design Variable", dv.name, dv.value)

for c in constraint_dict.keys():
    constraints_save_dict[c.name] = c.value
    print("Constraint", c.name, c.value)

for obj in obj_dict.keys():
    obj_save_dict[obj.name] = obj.value
    print("Objective", obj.name, obj.value)
    
pass
recorder.stop()